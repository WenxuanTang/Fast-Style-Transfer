<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.269">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>readme</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
</style>


<script src="README_files/libs/clipboard/clipboard.min.js"></script>
<script src="README_files/libs/quarto-html/quarto.js"></script>
<script src="README_files/libs/quarto-html/popper.min.js"></script>
<script src="README_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="README_files/libs/quarto-html/anchor.min.js"></script>
<link href="README_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="README_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="README_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="README_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="README_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">



<section id="neural-style-transfer" class="level1">
<h1>Neural Style Transfer</h1>
<p><strong>Group members: Yuejiao Qiu, Ruoting Shen, Wenxuan(Ivy) Tang, Yuening Wang, Sirui Wang</strong></p>
<section id="project-overview-and-objective" class="level2">
<h2 class="anchored" data-anchor-id="project-overview-and-objective">Project overview and objective</h2>
<p>We are inspired by the filter effects in diverse mobile applications that we can transform an image into another image which keeps the same content, such as objects and shapes while changing the styles. However, sometimes, the filters are not satisfying enough, it suffers from shading, brightness, contrast, etc. In this project, we aim to design a more flexible way to convert the image style completely. By providing another image, such as diverse artists’ masterpieces or various photographers’ work with distinct styles, we adopt these styles as the “filter effects” to transform the content image. The building block is to transform the style to the utmost extent while preserving the object in the original image as much as we could. Besides, we intended to try out different algorithms and network architectures to maximize the performance of style transformation as well as the runtime.</p>
</section>
<section id="proposed-data-source-and-methods" class="level2">
<h2 class="anchored" data-anchor-id="proposed-data-source-and-methods">Proposed Data Source and Methods</h2>
<p>The main algorithm we implement in the project is Convolutional Neural Network (CNN). Based on the previous research, neural style transfer (NST) has two main fields: image- optimization-based (IOB) online neural methods and model-optimization-based (MOB) offline neural methods. Basic style transfer realizes a style render of one fixed style to one fixed content using IOB-NST algorithms proposed by Gatys et. al(2016), which utilizes a pre-trained VGG19 as the loss network. For the MOB-NST model, we will basically follow Johnson et. al (2016) and Ulyanov et. al (2017) to use a feed-forward network optimized over a sufficiently large number of content images for each style. And Shen et. al (2018) proposed a novel method to generate specified network parameters in the meta networks, which archives real-time transfer of any style and content. But due to the limit of space and resources, it might be challenging for us to implement.</p>
<p>In the experiments, we attempt different models and choose the one with the best performance. Different algorithms and loss functions are included to evaluate the results. After comparison, we evaluate the selected model based on transformation accuracy at last.</p>
<section id="basic-style-transfer" class="level3">
<h3 class="anchored" data-anchor-id="basic-style-transfer">Basic style transfer</h3>
<p>IOB-NST algorithms extract style and content from source images to produce a target representation and then output the stylized results that match target representations through iterations (Jing et al., 2019). However, this model is also limited by its iterative optimization process, which leads to low efficiency. A pre-trained VGG-19 (Figure 1) is utilized as the loss network, implementing an irreversible network consisting of 16 layers of convolution and 5 layers of pooling. The selection of styles and content layers is an important part of style transformation. According to the study by Gatys et al.&nbsp;(2016), conv1_1, conv2_1, conv3_1, conv4_1, and conv5_1 are used as style layers and conv4_2 as the content layer. The loss can be calculated with the features in layers. The goal is to transfer the style of the source image onto the target image. The final new image matches both the content and style. And LBFG_S is utilized as an optimizer to iteratively adjust the gradient and minimize the total loss. <img src="img/Vgg-19.png" class="img-fluid"></p>
<section id="code" class="level4">
<h4 class="anchored" data-anchor-id="code">Code</h4>
<ol type="1">
<li><a href="/code/1_BasicStyleTransfer.ipynb">Basic Style Transfer</a></li>
</ol>
</section>
</section>
<section id="fast-style-transfer" class="level3">
<h3 class="anchored" data-anchor-id="fast-style-transfer">Fast style transfer</h3>
<p>Although the basic style transfer shows quite exceptional results, it still has many limitations, and the most significant one is the efficiency problem. That is, if a new style or content of the image is supposed to be used, the basic style transfer model requires inputting a new image and iterating every time. Therefore, in order to improve the speed and reduce the computational cost, the MOB-NST algorithms are implemented to create a new model which can conduct a real- time style transfer. The MOB-NST algorithm can be achieved through three methods, which are Per-Style- Per-Model (PSPM) MOB-NST methods, Multiple-Style-Per-Model (MSPM) MOB-NST Methods, and Arbitrary-Style-Per-Model (ASPM) MOB-NST Methods. The first two MOB-NST algorithms are raised by Ulyanov et al.&nbsp;and Johnson et al., both of them can pre-train a feed-forward network and generate stylized results with a single forward pass during the test phase (Jing et al., 2019). The only difference is that Johnson et al.&nbsp;use residual blocks and fractionally strided convolutions, while Ulyanov et al.&nbsp;use a multi-scale generator network (Jing et al., 2019).</p>
<p><img src="img/fast.png" class="img-fluid"></p>
<section id="code-1" class="level4">
<h4 class="anchored" data-anchor-id="code-1">Code</h4>
<ol type="1">
<li><a href="code/2_FastTransfer_Kanagawa.ipynb">Kanagawa Style Transfer</a></li>
<li><a href="code/2_FastTransfer_OldCanalPort.ipynb">Old Canal Port Style Transfer</a></li>
<li><a href="code/2_FastTransfer_Portrait.ipynb">Portrait Style Transfer</a></li>
<li><a href="code/2_FastTransfer_RainPrincess.ipynb">Rain Princess Style Transfer</a></li>
<li><a href="code/2_FastTransfer_Scream.ipynb">Scream Style Transfer</a></li>
<li><a href="code/2_FastTransfer_StarryNight.ipynb">Starry Night Style Transfer</a></li>
<li><a href="code/2_FastTransfer_WaterLilies.ipynb">WaterLilies Style Transfer</a></li>
</ol>
</section>
</section>
</section>
<section id="result" class="level2">
<h2 class="anchored" data-anchor-id="result">Result</h2>
<section id="basic-style-transfer-1" class="level3">
<h3 class="anchored" data-anchor-id="basic-style-transfer-1">Basic style transfer</h3>
<p>As Figure 3 shows, basic style transfer successfully transfers the textures of image style with the preservation of the content, and style and content are roughly mixed. Unfortunately, one major limitation is that the model requires a new input and iteration in order to use a new style or content of the image and iteratively apply the gradient descent to minimize the loss during the process. In the experiment with GPU, with the number of iterations set to 800, the average time to output the image is 63.27 seconds, which is too slow for business purposes. Therefore, fast style transfer is built to achieve the real-time style transfer, which will be conducted and discussed in the following. <img src="img/basic_transfer.png" class="img-fluid"></p>
</section>
<section id="fast-style-transfer-1" class="level3">
<h3 class="anchored" data-anchor-id="fast-style-transfer-1">Fast style transfer</h3>
<p>Figure 5 is a demonstration of the results for all models. The average time to transform a random image is approximately 0.17 seconds once the painting-specific style transfer model is trained, which partially implements real-time style transfer, especially when compared to the one- minute run time of the basic transfer. For a stronger test of the model performance, images with numbers were examined and better results were obtained. The model not only transferred the color but also the texture of the style painting. Simultaneously, the objects in the content images are well preserved, sharp object shapes can still be noticed in the output images, regardless of the relatively messy stylized paintings. <img src="img/fast_transfer.png" class="img-fluid"></p>
</section>
</section>
<section id="repository-structure" class="level2">
<h2 class="anchored" data-anchor-id="repository-structure">Repository structure</h2>
<p>The repository has the following structure:</p>
<pre class="."><code>├── README.md
├── code/
├── result/
├── writeup/
└── img/
</code></pre>
<section id="description" class="level3">
<h3 class="anchored" data-anchor-id="description">Description</h3>
<ul>
<li>The <code>code/</code> directory is where we wrote all of scripts.</li>
<li>The <code>result/</code> directory contains the visualization of the model result.</li>
<li>The <code>writeup/</code> directory contains our proposal final report and presentation slide.</li>
<li>The <code>img/</code> directory contains screenshots for the README.</li>
</ul>
</section>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>